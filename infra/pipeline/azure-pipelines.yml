trigger:
  branches:
    include:
    - main
  paths:
    include:
    - infra/*
    - infra/modules/*
    - infra/params/*

# Security scanning schedule
schedules:
- cron: "0 0 * * 0"
  displayName: Weekly security scan
  branches:
    include:
    - main
  always: true

parameters:
- name: performSecurityScan
  type: boolean
  default: true
  displayName: 'Perform Security Scan'
- name: validateResourceLocks
  type: boolean
  default: true
  displayName: 'Validate Resource Locks'

variables:
  # Enable secure variables handling
  - group: infrastructure-variables
  - group: security-scanning-variables
  # Enforce secure access pattern
  - name: System.Debug
    value: false # Prevent sensitive info in logs
  # Pipeline-specific variables
  - name: artifactName
    value: 'infrastructure'
  - name: bicepPath
    value: '$(System.DefaultWorkingDirectory)/infra'
  - name: deploymentName
    value: '$(environment)-$(Build.BuildNumber)'
  - name: monitoringEnabled
    value: true
  - name: autoRollbackEnabled
    value: true
  # Cost optimization controls
  - name: costOptimizationEnabled
    value: true
  # Granular cost controls for dev/test environments
  - name: synapseSqlPoolsPause
    value: true
  - name: synapseShirOptimize
    value: false  # Keep SHIR running by default for development
  - name: appServiceScaleDown
    value: true
  - name: eventHubsScaleDown
    value: true
  - name: vmDeallocate
    value: true
  - name: aksScaleDown
    value: true

stages:
- stage: PreDeploymentCheck
  displayName: 'Pre-deployment Validation'
  jobs:
  - job: ValidatePrerequisites
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      displayName: 'Check Prerequisites'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptPath: '$(System.DefaultWorkingDirectory)/infra/pipeline/check-prerequisites.sh'
        arguments: '$(location) $(namePrefix) $(environment)'

    - task: AzureCLI@2
      displayName: 'Validate Resource Names'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az deployment sub validate \
            --location $(location) \
            --template-file $(System.DefaultWorkingDirectory)/infra/modules/validation.bicep \
            --parameters \
              namePrefix=$(namePrefix) \
              environment=$(environment)

- stage: SecurityScan
  displayName: 'Security Scan'
  dependsOn: PreDeploymentCheck
  condition: succeeded() && eq(${{ parameters.performSecurityScan }}, true)
  jobs:
  - job: SecurityChecks
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      displayName: 'Run Checkov Security Scan'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          pip install checkov
          checkov -d $(System.DefaultWorkingDirectory)/infra --framework bicep

    - task: AzureCLI@2
      displayName: 'Run Tfsec Scan'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          wget -q -O - https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
          tfsec $(System.DefaultWorkingDirectory)/infra

- stage: DependencyValidation
  displayName: 'Dependency Validation'
  dependsOn: SecurityScan
  condition: succeeded()
  jobs:
  - job: DependencyChecks
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '8.x'

    - task: DotNetCoreCLI@2
      displayName: 'Restore Dependencies'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Run Dependency Vulnerability Scan'
      inputs:
        command: 'custom'
        custom: 'list'
        arguments: 'package --vulnerable --include-transitive'
        projects: '**/*.csproj'

    - task: PowerShell@2
      displayName: 'Validate Package License Compliance'
      inputs:
        targetType: 'inline'
        script: |
          # Install license checker
          dotnet tool install --global dotnet-project-licenses --version 2.5.0

          # Check licenses for all projects
          dotnet-project-licenses --input . --output licenses.json --json

          # Validate license compliance
          $licenses = Get-Content licenses.json | ConvertFrom-Json
          $incompatibleLicenses = $licenses.packages | Where-Object {
            $_.license -and (
              $_.license -like "*GPL*" -or
              $_.license -like "*LGPL*" -or
              $_.license -like "*MS-PL*" -or
              $_.license -like "*BSD*"
            )
          }

          if ($incompatibleLicenses.Count -gt 0) {
            Write-Error "Found incompatible licenses:"
            $incompatibleLicenses | ForEach-Object { Write-Error "$($_.package): $($_.license)" }
            exit 1
          }

    - task: PowerShell@2
      displayName: 'Check Package Version Consistency'
      inputs:
        targetType: 'inline'
        script: |
          # Find all project files
          $projectFiles = Get-ChildItem -Path . -Recurse -Filter "*.csproj" -File

          $versionIssues = @()

          foreach ($projectFile in $projectFiles) {
            $content = Get-Content $projectFile.FullName -Raw

            # Check for inconsistent package versions
            $packageRefs = [regex]::Matches($content, 'PackageReference Include="([^"]*)" Version="([^"]*)"')

            foreach ($match in $packageRefs) {
              $packageName = $match.Groups[1].Value
              $version = $match.Groups[2].Value

              # Flag packages with wildcard versions or very old versions
              if ($version -like "*.*.*.*" -or $version -like "*-*" -or $version -like "*alpha*" -or $version -like "*beta*") {
                $versionIssues += "Unstable version for $packageName in $($projectFile.Name): $version"
              }
            }
          }

          if ($versionIssues.Count -gt 0) {
            Write-Warning "Version consistency issues found:"
            $versionIssues | ForEach-Object { Write-Warning $_ }
          }

    - task: PowerShell@2
      displayName: 'Validate .NET SDK Version Consistency'
      inputs:
        targetType: 'inline'
        script: |
          # Check global.json
          if (Test-Path "global.json") {
            $globalJson = Get-Content "global.json" | ConvertFrom-Json
            $sdkVersion = $globalJson.sdk.version
            Write-Host "Global SDK version: $sdkVersion"
          }

          # Check all project files for TargetFramework consistency
          $projectFiles = Get-ChildItem -Path . -Recurse -Filter "*.csproj" -File
          $targetFrameworks = @()

          foreach ($projectFile in $projectFiles) {
            $content = Get-Content $projectFile.FullName -Raw
            $tfMatch = [regex]::Match($content, '<TargetFramework>([^<]*)</TargetFramework>')
            if ($tfMatch.Success) {
              $targetFrameworks += $tfMatch.Groups[1].Value
            }
          }

          $uniqueFrameworks = $targetFrameworks | Select-Object -Unique
          if ($uniqueFrameworks.Count -gt 1) {
            Write-Warning "Multiple target frameworks found: $($uniqueFrameworks -join ', ')"
            Write-Warning "Consider standardizing on a single framework version"
          }

    - task: AzureCLI@2
      displayName: 'Validate Bicep Module Dependencies'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Check for unused Bicep modules
          echo "Checking for unused Bicep modules..."

          # Find all Bicep files
          find infra -name "*.bicep" -type f | while read -r bicep_file; do
            module_name=$(basename "$bicep_file" .bicep)

            # Check if this module is referenced in main.bicep or other modules
            if ! grep -r "modules/$module_name" infra/ --include="*.bicep" | grep -v "$bicep_file" > /dev/null; then
              echo "WARNING: Module $module_name may be unused"
            fi
          done

    - task: AzureCLI@2
      displayName: 'Check for Outdated Dependencies'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Install dependency checker
          dotnet tool install --global dotnet-outdated-tool --version 4.5.0

          # Check for outdated packages
          dotnet outdated --output outdated-packages.json || true

          # Parse results and warn about major version updates
          if [ -f "outdated-packages.json" ]; then
            echo "Checking for major version updates..."
            # This would require more complex parsing in a real implementation
            echo "Dependency check completed"
          fi
  - job: BuildAndValidate
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzurePolicyCheckGate@0
      displayName: 'Azure Policy Compliance Check'
      inputs:
        azureSubscription: '$(serviceConnection)'
        resourceGroupName: '$(resourceGroup)'
        
    - task: AzureKeyVault@2
      inputs:
        azureSubscription: '$(serviceConnection)'
        KeyVaultName: '$(keyVaultName)'
        SecretsFilter: '*'
        RunAsPreJob: true
    - task: AzureCLI@2
      displayName: 'Install Bicep Tools'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az bicep install
          az bicep version

    - task: AzureCLI@2
      displayName: 'Validate Bicep Files'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az bicep build --file $(bicepPath)/main.bicep --outfile $(Build.ArtifactStagingDirectory)/main.json
          az deployment sub what-if --location $(location) --template-file $(bicepPath)/main.bicep

    - task: CopyFiles@2
      displayName: 'Copy Infrastructure Files'
      inputs:
        Contents: |
          infra/**
          !infra/**/*.md
        TargetFolder: '$(Build.ArtifactStagingDirectory)'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Infrastructure Artifacts'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: '$(artifactName)'
        publishLocation: 'Container'

# Development Deployment
- template: deployment-stage-template.yml
  parameters:
    environment: 'DEV'
    dependsOn: 'DependencyValidation'

# SIT Deployment
- template: deployment-stage-template.yml
  parameters:
    environment: 'SIT'
    dependsOn: 'DeployToDEV'

# Production Deployment
- template: deployment-stage-template.yml
  parameters:
    environment: 'PROD'
    dependsOn: 'DeployToSIT'